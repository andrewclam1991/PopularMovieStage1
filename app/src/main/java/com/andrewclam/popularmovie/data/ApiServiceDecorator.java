package com.andrewclam.popularmovie.data;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.VisibleForTesting;

import com.andrewclam.popularmovie.data.api.TMDBApiService;
import com.andrewclam.popularmovie.data.model.Entity;
import com.andrewclam.popularmovie.data.model.Movie;
import com.google.common.base.Optional;
import com.google.common.base.Strings;

import java.util.List;
import java.util.Map;

import io.reactivex.BackpressureStrategy;
import io.reactivex.Completable;
import io.reactivex.Flowable;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;

public class ApiServiceDecorator<E extends Entity> implements DataSource<E> {

  @NonNull
  private final DataSource<E> mRepository;

  @Nullable
  private TMDBApiService<E> mApiService;

  @Nullable
  private String mApiKey;

  @Nullable
  private Map<String, String> mOptions;

  /**
   * Marks the cache as invalid, to force an update the next time data is requested. This variable
   * has package local visibility so it can be accessed from tests.
   * Note: default set flag to false, so at init (with mCachedItems empty),
   * repository will always try local-first
   */
  @VisibleForTesting
  boolean mCacheIsDirty = false;

  public ApiServiceDecorator(@NonNull DataSource<E> repository) {
    mRepository = repository;
  }

  @NonNull
  public ApiServiceDecorator<E> setApiService(@NonNull OnRequestApiService<E> callback) {
    mApiService = callback.provideApiService();
    return this;
  }

  /**
   * add a behavior that allows client to supply the api key
   *
   * @param callback when client sets the api key via a functional callback
   *                 this allows client to vary argument at runtime instead of supplying
   *                 static arguments.
   * @return an instance of wrapper class to maintain api fluency.
   */
  @NonNull
  public ApiServiceDecorator<E> setApiKey(@NonNull OnRequestApiKeyCallback callback) {
    mApiKey = callback.provideApiKey();
    return this;
  }

  /**
   * add a behavior that allows client to supply optional query options
   *
   * @param callback when client sets a query option via a functional callback
   *                 this allows client to vary argument at runtime instead of supplying
   *                 static arguments.
   * @return an instance of the wrapper class to maintain api fluency.
   */
  @NonNull
  public ApiServiceDecorator<E> setQueryParams(@NonNull OnRequestOptionsCallback callback) {
    mOptions = callback.provideOptions();
    return this;
  }

  /**
   * Functional interface for client to provide the api key {@link String}
   */
  public interface OnRequestApiKeyCallback {
    @NonNull
    String provideApiKey();
  }

  /**
   * Functional interface for client to provide the optional query parameters (options)
   * with a {@link Map<String,String>}, where the key is the query parameter and the value
   * is the argument.
   */
  public interface OnRequestOptionsCallback {
    @Nullable
    Map<String, String> provideOptions();
  }

  /**
   * Functional interface for client to provide the required api service generated by
   * {@link retrofit2.Retrofit}
   */
  public interface OnRequestApiService<E extends Entity> {
    @NonNull
    TMDBApiService<E> provideApiService();
  }

  // Decorated behaviors
  @Override
  public final Flowable<List<E>> getItems() {
    if (Strings.isNullOrEmpty(mApiKey)) {
      throw new IllegalArgumentException("Developer error, did you call setApiKey()?");
    }

    if (mApiService == null) {
      throw new IllegalArgumentException("Developer error, did you call setApiService()?");
    }

    // when cache is dirty, use "getItems(uri)" behavior
    if (mCacheIsDirty) {
      return getItems(mApiService, mApiKey, mOptions);
    } else {
      // else, use repository first, use "getItems(uri)" behavior ONLY when first stream is empty
      return mRepository.getItems().switchIfEmpty(getItems(mApiService, mApiKey, mOptions));
    }
  }

  @Override
  public final void refresh() {
    mCacheIsDirty = true;
    mRepository.refresh();
  }

  /**
   * Uses {@link retrofit2.Retrofit} to make the generic call to the {@code apiService}
   *
   * @param apiKey  the developer api key
   * @param options optional query options
   * @return an observable list of items
   */
  @NonNull
  private Flowable<List<E>> getItems(@NonNull TMDBApiService<E> apiService,
                                     @NonNull String apiKey,
                                     @Nullable Map<String, String> options) {
    return Flowable.create(emitter -> {
      Call<List<E>> mCall = apiService.getItems(apiKey, options);
      mCall.enqueue(new Callback<List<E>>() {
        @Override
        public void onResponse(@NonNull Call<List<E>> call, @NonNull Response<List<E>> response) {
          emitter.onNext(response.body());
          emitter.onComplete();
        }

        @Override
        public void onFailure(@NonNull Call<List<E>> call, @NonNull Throwable t) {
          emitter.onError(t);
        }
      });
    }, BackpressureStrategy.BUFFER);
  }

  // Unmodified behaviors
  @Override
  public final Flowable<Optional<E>> getItem(@NonNull String entityId) {
    return mRepository.getItem(entityId);
  }

  @Override
  public final Completable add(@NonNull E item) {
    return mRepository.add(item);
  }

  @Override
  public final Completable addAll(@NonNull List<E> items) {
    return mRepository.addAll(items);
  }

  @Override
  public final Completable update(@NonNull E item) {
    return mRepository.update(item);
  }

  @Override
  public final Completable remove(@NonNull String entityId) {
    return mRepository.remove(entityId);
  }

  @Override
  public final Completable removeAll() {
    return mRepository.removeAll();
  }

}
